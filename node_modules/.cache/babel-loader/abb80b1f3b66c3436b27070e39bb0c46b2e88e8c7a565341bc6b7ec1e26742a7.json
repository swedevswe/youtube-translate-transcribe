{"ast":null,"code":"const dollarStub = /\\$[0-9a-z]+/g;\nconst fns = {};\nconst titleCase = function (str) {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase());\n};\n\n// doc.replace('foo', (m)=>{})\nconst replaceByFn = function (main, fn) {\n  main.forEach(m => {\n    let out = fn(m);\n    m.replaceWith(out);\n  });\n  return main;\n};\n\n// support 'foo $0' replacements\nconst subDollarSign = function (input, main) {\n  if (typeof input !== 'string') {\n    return input;\n  }\n  let groups = main.groups();\n  input = input.replace(dollarStub, a => {\n    let num = a.replace(/\\$/, '');\n    if (groups.hasOwnProperty(num)) {\n      return groups[num].text();\n    }\n    return a;\n  });\n  return input;\n};\nfns.replaceWith = function (input) {\n  let keep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let ptrs = this.fullPointer;\n  let main = this;\n  this.uncache();\n  if (typeof input === 'function') {\n    return replaceByFn(main, input);\n  }\n  let terms = main.docs[0];\n  let isPossessive = keep.possessives && terms[terms.length - 1].tags.has('Possessive');\n  // support 'foo $0' replacements\n  input = subDollarSign(input, main);\n  let original = this.update(ptrs);\n  // soften-up pointer\n  ptrs = ptrs.map(ptr => ptr.slice(0, 3));\n  // original.freeze()\n  let oldTags = (original.docs[0] || []).map(term => Array.from(term.tags));\n  // slide this in\n  if (typeof input === 'string') {\n    input = this.fromText(input).compute('id');\n  }\n  main.insertAfter(input);\n  // are we replacing part of a contraction?\n  if (original.has('@hasContraction') && main.contractions) {\n    let more = main.grow('@hasContraction+');\n    more.contractions().expand();\n  }\n  // delete the original terms\n  main.delete(original); //science.\n\n  // keep \"John's\"\n  if (isPossessive) {\n    let tmp = main.docs[0];\n    let term = tmp[tmp.length - 1];\n    if (!term.tags.has('Possessive')) {\n      term.text += \"'s\";\n      term.normal += \"'s\";\n      term.tags.add('Possessive');\n    }\n  }\n  // what should we return?\n  let m = main.toView(ptrs).compute(['index', 'freeze', 'lexicon']);\n  if (m.world.compute.preTagger) {\n    m.compute('preTagger');\n  }\n  m.compute('unfreeze');\n  // replace any old tags\n  if (keep.tags) {\n    m.terms().forEach((term, i) => {\n      term.tagSafe(oldTags[i]);\n    });\n  }\n  // try to co-erce case, too\n  if (keep.case && m.docs[0] && m.docs[0][0] && m.docs[0][0].index[1] === 0) {\n    m.docs[0][0].text = titleCase(m.docs[0][0].text);\n  }\n\n  // try to keep some pre-post punctuation\n  // if (m.terms().length === 1 && main.terms().length === 1) {\n  //   console.log(original.docs)\n  // }\n\n  // console.log(input.docs[0])\n  // let regs = input.docs[0].map(t => {\n  //   return { id: t.id, optional: true }\n  // })\n  // m.after('(a|hoy)').debug()\n  // m.growRight('(a|hoy)').debug()\n  // console.log(m)\n  return m;\n};\nfns.replace = function (match, input, keep) {\n  if (match && !input) {\n    return this.replaceWith(match, keep);\n  }\n  let m = this.match(match);\n  if (!m.found) {\n    return this;\n  }\n  this.soften();\n  return m.replaceWith(input, keep);\n};\nexport default fns;","map":{"version":3,"names":["dollarStub","fns","titleCase","str","replace","txt","charAt","toUpperCase","substring","toLowerCase","replaceByFn","main","fn","forEach","m","out","replaceWith","subDollarSign","input","groups","a","num","hasOwnProperty","text","keep","arguments","length","undefined","ptrs","fullPointer","uncache","terms","docs","isPossessive","possessives","tags","has","original","update","map","ptr","slice","oldTags","term","Array","from","fromText","compute","insertAfter","contractions","more","grow","expand","delete","tmp","normal","add","toView","world","preTagger","i","tagSafe","case","index","match","found","soften"],"sources":["C:/Users/swths/node_modules/compromise/src/1-one/change/api/replace.js"],"sourcesContent":["const dollarStub = /\\$[0-9a-z]+/g\nconst fns = {}\n\nconst titleCase = function (str) {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase())\n}\n\n// doc.replace('foo', (m)=>{})\nconst replaceByFn = function (main, fn) {\n  main.forEach(m => {\n    let out = fn(m)\n    m.replaceWith(out)\n  })\n  return main\n}\n\n// support 'foo $0' replacements\nconst subDollarSign = function (input, main) {\n  if (typeof input !== 'string') {\n    return input\n  }\n  let groups = main.groups()\n  input = input.replace(dollarStub, a => {\n    let num = a.replace(/\\$/, '')\n    if (groups.hasOwnProperty(num)) {\n      return groups[num].text()\n    }\n    return a\n  })\n  return input\n}\n\nfns.replaceWith = function (input, keep = {}) {\n  let ptrs = this.fullPointer\n  let main = this\n  this.uncache()\n  if (typeof input === 'function') {\n    return replaceByFn(main, input)\n  }\n  let terms = main.docs[0]\n  let isPossessive = keep.possessives && terms[terms.length - 1].tags.has('Possessive')\n  // support 'foo $0' replacements\n  input = subDollarSign(input, main)\n\n  let original = this.update(ptrs)\n  // soften-up pointer\n  ptrs = ptrs.map(ptr => ptr.slice(0, 3))\n  // original.freeze()\n  let oldTags = (original.docs[0] || []).map(term => Array.from(term.tags))\n  // slide this in\n  if (typeof input === 'string') {\n    input = this.fromText(input).compute('id')\n  }\n  main.insertAfter(input)\n  // are we replacing part of a contraction?\n  if (original.has('@hasContraction') && main.contractions) {\n    let more = main.grow('@hasContraction+')\n    more.contractions().expand()\n  }\n  // delete the original terms\n  main.delete(original) //science.\n\n  // keep \"John's\"\n  if (isPossessive) {\n    let tmp = main.docs[0]\n    let term = tmp[tmp.length - 1]\n    if (!term.tags.has('Possessive')) {\n      term.text += \"'s\"\n      term.normal += \"'s\"\n      term.tags.add('Possessive')\n    }\n  }\n  // what should we return?\n  let m = main.toView(ptrs).compute(['index', 'freeze', 'lexicon'])\n  if (m.world.compute.preTagger) {\n    m.compute('preTagger')\n  }\n  m.compute('unfreeze')\n  // replace any old tags\n  if (keep.tags) {\n    m.terms().forEach((term, i) => {\n      term.tagSafe(oldTags[i])\n    })\n  }\n  // try to co-erce case, too\n  if (keep.case && m.docs[0] && m.docs[0][0] && m.docs[0][0].index[1] === 0) {\n    m.docs[0][0].text = titleCase(m.docs[0][0].text)\n  }\n\n  // try to keep some pre-post punctuation\n  // if (m.terms().length === 1 && main.terms().length === 1) {\n  //   console.log(original.docs)\n  // }\n\n  // console.log(input.docs[0])\n  // let regs = input.docs[0].map(t => {\n  //   return { id: t.id, optional: true }\n  // })\n  // m.after('(a|hoy)').debug()\n  // m.growRight('(a|hoy)').debug()\n  // console.log(m)\n  return m\n}\n\nfns.replace = function (match, input, keep) {\n  if (match && !input) {\n    return this.replaceWith(match, keep)\n  }\n  let m = this.match(match)\n  if (!m.found) {\n    return this\n  }\n  this.soften()\n  return m.replaceWith(input, keep)\n}\nexport default fns\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}