{"ast":null,"code":"/* eslint no-console: 0 */\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\nconst fns = {\n  /** add a given tag, to all these terms */\n  tag: function (input) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let isSafe = arguments.length > 2 ? arguments[2] : undefined;\n    if (!this.found || !input) {\n      return this;\n    }\n    let terms = this.termList();\n    if (terms.length === 0) {\n      return this;\n    }\n    const {\n      methods,\n      verbose,\n      world\n    } = this;\n    // logger\n    if (verbose === true) {\n      console.log(' +  ', input, reason || '');\n    }\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.setTag(terms, tag, world, isSafe, reason));\n    } else {\n      methods.one.setTag(terms, input, world, isSafe, reason);\n    }\n    // uncache\n    this.uncache();\n    return this;\n  },\n  /** add a given tag, only if it is consistent */\n  tagSafe: function (input) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return this.tag(input, reason, true);\n  },\n  /** remove a given tag from all these terms */\n  unTag: function (input, reason) {\n    if (!this.found || !input) {\n      return this;\n    }\n    let terms = this.termList();\n    if (terms.length === 0) {\n      return this;\n    }\n    const {\n      methods,\n      verbose,\n      model\n    } = this;\n    // logger\n    if (verbose === true) {\n      console.log(' -  ', input, reason || '');\n    }\n    let tagSet = model.one.tagSet;\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.unTag(terms, tag, tagSet));\n    } else {\n      methods.one.unTag(terms, input, tagSet);\n    }\n    // uncache\n    this.uncache();\n    return this;\n  },\n  /** return only the terms that can be this tag  */\n  canBe: function (tag) {\n    tag = tag.replace(/^#/, '');\n    let tagSet = this.model.one.tagSet;\n    let canBe = this.methods.one.canBe;\n    let nope = [];\n    this.document.forEach((terms, n) => {\n      terms.forEach((term, i) => {\n        if (!canBe(term, tag, tagSet)) {\n          nope.push([n, i, i + 1]);\n        }\n      });\n    });\n    let noDoc = this.update(nope);\n    return this.difference(noDoc);\n  }\n};\nexport default fns;","map":{"version":3,"names":["isArray","arr","Object","prototype","toString","call","fns","tag","input","reason","arguments","length","undefined","isSafe","found","terms","termList","methods","verbose","world","console","log","forEach","one","setTag","uncache","tagSafe","unTag","model","tagSet","canBe","replace","nope","document","n","term","i","push","noDoc","update","difference"],"sources":["C:/Users/swths/node_modules/compromise/src/1-one/tag/api/tag.js"],"sourcesContent":["/* eslint no-console: 0 */\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\nconst fns = {\n  /** add a given tag, to all these terms */\n  tag: function (input, reason = '', isSafe) {\n    if (!this.found || !input) {\n      return this\n    }\n    let terms = this.termList()\n    if (terms.length === 0) {\n      return this\n    }\n    const { methods, verbose, world } = this\n    // logger\n    if (verbose === true) {\n      console.log(' +  ', input, reason || '')\n    }\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.setTag(terms, tag, world, isSafe, reason))\n    } else {\n      methods.one.setTag(terms, input, world, isSafe, reason)\n    }\n    // uncache\n    this.uncache()\n    return this\n  },\n\n  /** add a given tag, only if it is consistent */\n  tagSafe: function (input, reason = '') {\n    return this.tag(input, reason, true)\n  },\n\n  /** remove a given tag from all these terms */\n  unTag: function (input, reason) {\n    if (!this.found || !input) {\n      return this\n    }\n    let terms = this.termList()\n    if (terms.length === 0) {\n      return this\n    }\n    const { methods, verbose, model } = this\n    // logger\n    if (verbose === true) {\n      console.log(' -  ', input, reason || '')\n    }\n    let tagSet = model.one.tagSet\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.unTag(terms, tag, tagSet))\n    } else {\n      methods.one.unTag(terms, input, tagSet)\n    }\n    // uncache\n    this.uncache()\n    return this\n  },\n\n  /** return only the terms that can be this tag  */\n  canBe: function (tag) {\n    tag = tag.replace(/^#/, '')\n    let tagSet = this.model.one.tagSet\n    let canBe = this.methods.one.canBe\n    let nope = []\n    this.document.forEach((terms, n) => {\n      terms.forEach((term, i) => {\n        if (!canBe(term, tag, tagSet)) {\n          nope.push([n, i, i + 1])\n        }\n      })\n    })\n    let noDoc = this.update(nope)\n    return this.difference(noDoc)\n  },\n}\nexport default fns\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}