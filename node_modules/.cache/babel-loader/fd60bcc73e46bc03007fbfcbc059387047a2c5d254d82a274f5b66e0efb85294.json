{"ast":null,"code":"import world from './world.js';\nimport api from './methods/index.js';\nclass View {\n  constructor(document, pointer) {\n    let groups = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // invisible props\n    let props = [['document', document], ['world', world], ['_groups', groups], ['_cache', null], ['viewType', 'View']];\n    props.forEach(a => {\n      Object.defineProperty(this, a[0], {\n        value: a[1],\n        writable: true\n      });\n    });\n    this.ptrs = pointer;\n  }\n  /* getters:  */\n  get docs() {\n    let docs = this.document;\n    if (this.ptrs) {\n      docs = world.methods.one.getDoc(this.ptrs, this.document);\n    }\n    return docs;\n  }\n  get pointer() {\n    return this.ptrs;\n  }\n  get methods() {\n    return this.world.methods;\n  }\n  get model() {\n    return this.world.model;\n  }\n  get hooks() {\n    return this.world.hooks;\n  }\n  get isView() {\n    return true; //this comes in handy sometimes\n  }\n  // is the view not-empty?\n  get found() {\n    return this.docs.length > 0;\n  }\n  // how many matches we have\n  get length() {\n    return this.docs.length;\n  }\n  // return a more-hackable pointer\n  get fullPointer() {\n    let {\n      docs,\n      ptrs,\n      document\n    } = this;\n    // compute a proper pointer, from docs\n    let pointers = ptrs || docs.map((_d, n) => [n]);\n    // do we need to repair it, first?\n    return pointers.map(a => {\n      let [n, start, end, id, endId] = a;\n      start = start || 0;\n      end = end || (document[n] || []).length;\n      //add frozen id, for good-measure\n      if (document[n] && document[n][start]) {\n        id = id || document[n][start].id;\n        if (document[n][end - 1]) {\n          endId = endId || document[n][end - 1].id;\n        }\n      }\n      return [n, start, end, id, endId];\n    });\n  }\n  // create a new View, from this one\n  update(pointer) {\n    let m = new View(this.document, pointer);\n    // send the cache down, too?\n    if (this._cache && pointer && pointer.length > 0) {\n      // only keep cache if it's a full-sentence\n      let cache = [];\n      pointer.forEach((ptr, i) => {\n        let [n, start, end] = ptr;\n        if (ptr.length === 1) {\n          cache[i] = this._cache[n];\n        } else if (start === 0 && this.document[n].length === end) {\n          cache[i] = this._cache[n];\n        }\n      });\n      if (cache.length > 0) {\n        m._cache = cache;\n      }\n    }\n    m.world = this.world;\n    return m;\n  }\n  // create a new View, from this one\n  toView(pointer) {\n    return new View(this.document, pointer || this.pointer);\n  }\n  fromText(input) {\n    const {\n      methods\n    } = this;\n    //assume ./01-tokenize is installed\n    let document = methods.one.tokenize.fromString(input, this.world);\n    let doc = new View(document);\n    doc.world = this.world;\n    doc.compute(['normal', 'freeze', 'lexicon']);\n    if (this.world.compute.preTagger) {\n      doc.compute('preTagger');\n    }\n    doc.compute('unfreeze');\n    return doc;\n  }\n  clone() {\n    // clone the whole document\n    let document = this.document.slice(0); //node 17: structuredClone(document);\n    document = document.map(terms => {\n      return terms.map(term => {\n        term = Object.assign({}, term);\n        term.tags = new Set(term.tags);\n        return term;\n      });\n    });\n    // clone only sub-document ?\n    let m = this.update(this.pointer);\n    m.document = document;\n    m._cache = this._cache; //clone this too?\n    return m;\n  }\n}\nObject.assign(View.prototype, api);\nexport default View;","map":{"version":3,"names":["world","api","View","constructor","document","pointer","groups","arguments","length","undefined","props","forEach","a","Object","defineProperty","value","writable","ptrs","docs","methods","one","getDoc","model","hooks","isView","found","fullPointer","pointers","map","_d","n","start","end","id","endId","update","m","_cache","cache","ptr","i","toView","fromText","input","tokenize","fromString","doc","compute","preTagger","clone","slice","terms","term","assign","tags","Set","prototype"],"sources":["C:/Users/swths/node_modules/compromise/src/API/View.js"],"sourcesContent":["import world from './world.js'\nimport api from './methods/index.js'\n\nclass View {\n  constructor(document, pointer, groups = {}) {\n    // invisible props\n    let props = [\n      ['document', document],\n      ['world', world],\n      ['_groups', groups],\n      ['_cache', null],\n      ['viewType', 'View'],\n    ]\n    props.forEach(a => {\n      Object.defineProperty(this, a[0], {\n        value: a[1],\n        writable: true,\n      })\n    })\n    this.ptrs = pointer\n  }\n  /* getters:  */\n  get docs() {\n    let docs = this.document\n    if (this.ptrs) {\n      docs = world.methods.one.getDoc(this.ptrs, this.document)\n    }\n    return docs\n  }\n  get pointer() {\n    return this.ptrs\n  }\n  get methods() {\n    return this.world.methods\n  }\n  get model() {\n    return this.world.model\n  }\n  get hooks() {\n    return this.world.hooks\n  }\n  get isView() {\n    return true //this comes in handy sometimes\n  }\n  // is the view not-empty?\n  get found() {\n    return this.docs.length > 0\n  }\n  // how many matches we have\n  get length() {\n    return this.docs.length\n  }\n  // return a more-hackable pointer\n  get fullPointer() {\n    let { docs, ptrs, document } = this\n    // compute a proper pointer, from docs\n    let pointers = ptrs || docs.map((_d, n) => [n])\n    // do we need to repair it, first?\n    return pointers.map(a => {\n      let [n, start, end, id, endId] = a\n      start = start || 0\n      end = end || (document[n] || []).length\n      //add frozen id, for good-measure\n      if (document[n] && document[n][start]) {\n        id = id || document[n][start].id\n        if (document[n][end - 1]) {\n          endId = endId || document[n][end - 1].id\n        }\n      }\n      return [n, start, end, id, endId]\n    })\n  }\n  // create a new View, from this one\n  update(pointer) {\n    let m = new View(this.document, pointer)\n    // send the cache down, too?\n    if (this._cache && pointer && pointer.length > 0) {\n      // only keep cache if it's a full-sentence\n      let cache = []\n      pointer.forEach((ptr, i) => {\n        let [n, start, end] = ptr\n        if (ptr.length === 1) {\n          cache[i] = this._cache[n]\n        } else if (start === 0 && this.document[n].length === end) {\n          cache[i] = this._cache[n]\n        }\n      })\n      if (cache.length > 0) {\n        m._cache = cache\n      }\n    }\n    m.world = this.world\n    return m\n  }\n  // create a new View, from this one\n  toView(pointer) {\n    return new View(this.document, pointer || this.pointer)\n  }\n  fromText(input) {\n    const { methods } = this\n    //assume ./01-tokenize is installed\n    let document = methods.one.tokenize.fromString(input, this.world)\n    let doc = new View(document)\n    doc.world = this.world\n    doc.compute(['normal', 'freeze', 'lexicon'])\n    if (this.world.compute.preTagger) {\n      doc.compute('preTagger')\n    }\n    doc.compute('unfreeze')\n    return doc\n  }\n  clone() {\n    // clone the whole document\n    let document = this.document.slice(0) //node 17: structuredClone(document);\n    document = document.map(terms => {\n      return terms.map(term => {\n        term = Object.assign({}, term)\n        term.tags = new Set(term.tags)\n        return term\n      })\n    })\n    // clone only sub-document ?\n    let m = this.update(this.pointer)\n    m.document = document\n    m._cache = this._cache //clone this too?\n    return m\n  }\n}\nObject.assign(View.prototype, api)\nexport default View\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}