{"ast":null,"code":"import doesMatch from '../../term/doesMatch.js';\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\nexport const doOrBlock = function (state) {\n  let skipN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let block = state.regs[state.r];\n  let wasFound = false;\n  // do each multiword sequence\n  for (let c = 0; c < block.choices.length; c += 1) {\n    // try to match this list of tokens\n    let regs = block.choices[c];\n    if (!isArray(regs)) {\n      return false;\n    }\n    wasFound = regs.every((cr, w_index) => {\n      let extra = 0;\n      let t = state.t + w_index + skipN + extra;\n      if (state.terms[t] === undefined) {\n        return false;\n      }\n      let foundBlock = doesMatch(state.terms[t], cr, t + state.start_i, state.phrase_length);\n      // this can be greedy - '(foo+ bar)'\n      if (foundBlock === true && cr.greedy === true) {\n        for (let i = 1; i < state.terms.length; i += 1) {\n          let term = state.terms[t + i];\n          if (term) {\n            let keepGoing = doesMatch(term, cr, state.start_i + i, state.phrase_length);\n            if (keepGoing === true) {\n              extra += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      skipN += extra;\n      return foundBlock;\n    });\n    if (wasFound) {\n      skipN += regs.length;\n      break;\n    }\n  }\n  // we found a match -  is it greedy though?\n  if (wasFound && block.greedy === true) {\n    return doOrBlock(state, skipN); // try it again!\n  }\n  return skipN;\n};\nconst doAndBlock = function (state) {\n  let longest = 0;\n  // all blocks must match, and we return the greediest match\n  let reg = state.regs[state.r];\n  let allDidMatch = reg.choices.every(block => {\n    //  for multi-word blocks, all must match\n    let allWords = block.every((cr, w_index) => {\n      let tryTerm = state.t + w_index;\n      if (state.terms[tryTerm] === undefined) {\n        return false;\n      }\n      return doesMatch(state.terms[tryTerm], cr, tryTerm, state.phrase_length);\n    });\n    if (allWords === true && block.length > longest) {\n      longest = block.length;\n    }\n    return allWords;\n  });\n  if (allDidMatch === true) {\n    // console.log(`doAndBlock ${state.terms[state.t].normal}`)\n    return longest;\n  }\n  return false;\n};\nexport { doAndBlock };","map":{"version":3,"names":["doesMatch","isArray","arr","Object","prototype","toString","call","doOrBlock","state","skipN","arguments","length","undefined","block","regs","r","wasFound","c","choices","every","cr","w_index","extra","t","terms","foundBlock","start_i","phrase_length","greedy","i","term","keepGoing","doAndBlock","longest","reg","allDidMatch","allWords","tryTerm"],"sources":["C:/Users/swths/node_modules/compromise/src/1-one/match/methods/match/steps/logic/and-or.js"],"sourcesContent":["import doesMatch from '../../term/doesMatch.js'\n\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\n\nexport const doOrBlock = function (state, skipN = 0) {\n  let block = state.regs[state.r]\n  let wasFound = false\n  // do each multiword sequence\n  for (let c = 0; c < block.choices.length; c += 1) {\n    // try to match this list of tokens\n    let regs = block.choices[c]\n    if (!isArray(regs)) {\n      return false\n    }\n    wasFound = regs.every((cr, w_index) => {\n      let extra = 0\n      let t = state.t + w_index + skipN + extra\n      if (state.terms[t] === undefined) {\n        return false\n      }\n      let foundBlock = doesMatch(state.terms[t], cr, t + state.start_i, state.phrase_length)\n      // this can be greedy - '(foo+ bar)'\n      if (foundBlock === true && cr.greedy === true) {\n        for (let i = 1; i < state.terms.length; i += 1) {\n          let term = state.terms[t + i]\n          if (term) {\n            let keepGoing = doesMatch(term, cr, state.start_i + i, state.phrase_length)\n            if (keepGoing === true) {\n              extra += 1\n            } else {\n              break\n            }\n          }\n        }\n      }\n      skipN += extra\n      return foundBlock\n    })\n    if (wasFound) {\n      skipN += regs.length\n      break\n    }\n  }\n  // we found a match -  is it greedy though?\n  if (wasFound && block.greedy === true) {\n    return doOrBlock(state, skipN) // try it again!\n  }\n  return skipN\n}\n\nconst doAndBlock = function (state) {\n  let longest = 0\n  // all blocks must match, and we return the greediest match\n  let reg = state.regs[state.r]\n  let allDidMatch = reg.choices.every(block => {\n    //  for multi-word blocks, all must match\n    let allWords = block.every((cr, w_index) => {\n      let tryTerm = state.t + w_index\n      if (state.terms[tryTerm] === undefined) {\n        return false\n      }\n      return doesMatch(state.terms[tryTerm], cr, tryTerm, state.phrase_length)\n    })\n    if (allWords === true && block.length > longest) {\n      longest = block.length\n    }\n    return allWords\n  })\n  if (allDidMatch === true) {\n    // console.log(`doAndBlock ${state.terms[state.t].normal}`)\n    return longest\n  }\n  return false\n}\nexport { doAndBlock }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}