{"ast":null,"code":"// 01- full-word exceptions\nconst checkEx = function (str) {\n  let ex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (ex.hasOwnProperty(str)) {\n    return ex[str];\n  }\n  return null;\n};\n\n// 02- suffixes that pass our word through\nconst checkSame = function (str) {\n  let same = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  for (let i = 0; i < same.length; i += 1) {\n    if (str.endsWith(same[i])) {\n      return str;\n    }\n  }\n  return null;\n};\n\n// 03- check rules - longest first\nconst checkRules = function (str, fwd) {\n  let both = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  fwd = fwd || {};\n  let max = str.length - 1;\n  // look for a matching suffix\n  for (let i = max; i >= 1; i -= 1) {\n    let size = str.length - i;\n    let suff = str.substring(size, str.length);\n    // check fwd rules, first\n    if (fwd.hasOwnProperty(suff) === true) {\n      return str.slice(0, size) + fwd[suff];\n    }\n    // check shared rules\n    if (both.hasOwnProperty(suff) === true) {\n      return str.slice(0, size) + both[suff];\n    }\n  }\n  // try a fallback transform\n  if (fwd.hasOwnProperty('')) {\n    return str += fwd[''];\n  }\n  if (both.hasOwnProperty('')) {\n    return str += both[''];\n  }\n  return null;\n};\n\n//sweep-through all suffixes\nconst convert = function () {\n  let str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // 01- check exceptions\n  let out = checkEx(str, model.ex);\n  // 02 - check same\n  out = out || checkSame(str, model.same);\n  // check forward and both rules\n  out = out || checkRules(str, model.fwd, model.both);\n  //return unchanged\n  out = out || str;\n  return out;\n};\nexport default convert;","map":{"version":3,"names":["checkEx","str","ex","arguments","length","undefined","hasOwnProperty","checkSame","same","i","endsWith","checkRules","fwd","both","max","size","suff","substring","slice","convert","model","out"],"sources":["C:/Users/swths/node_modules/suffix-thumb/src/convert/index.js"],"sourcesContent":["\n// 01- full-word exceptions\nconst checkEx = function (str, ex = {}) {\n  if (ex.hasOwnProperty(str)) {\n    return ex[str]\n  }\n  return null\n}\n\n// 02- suffixes that pass our word through\nconst checkSame = function (str, same = []) {\n  for (let i = 0; i < same.length; i += 1) {\n    if (str.endsWith(same[i])) {\n      return str\n    }\n  }\n  return null\n}\n\n// 03- check rules - longest first\nconst checkRules = function (str, fwd, both = {}) {\n  fwd = fwd || {}\n  let max = str.length - 1\n  // look for a matching suffix\n  for (let i = max; i >= 1; i -= 1) {\n    let size = str.length - i\n    let suff = str.substring(size, str.length)\n    // check fwd rules, first\n    if (fwd.hasOwnProperty(suff) === true) {\n      return str.slice(0, size) + fwd[suff]\n    }\n    // check shared rules\n    if (both.hasOwnProperty(suff) === true) {\n      return str.slice(0, size) + both[suff]\n    }\n  }\n  // try a fallback transform\n  if (fwd.hasOwnProperty('')) {\n    return str += fwd['']\n  }\n  if (both.hasOwnProperty('')) {\n    return str += both['']\n  }\n  return null\n}\n\n//sweep-through all suffixes\nconst convert = function (str = '', model = {}) {\n  // 01- check exceptions\n  let out = checkEx(str, model.ex)\n  // 02 - check same\n  out = out || checkSame(str, model.same)\n  // check forward and both rules\n  out = out || checkRules(str, model.fwd, model.both)\n  //return unchanged\n  out = out || str\n  return out\n}\nexport default convert"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}